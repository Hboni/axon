# -*- coding: utf-8 -*-
#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL license version 2 under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the
# terms of the CeCILL license version 2 as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL license version 2 and that you accept its terms.

#------------------------------------------------------------------------------        
# FROM spm documentation (SPM8 manual: www.fil.ion.ucl.ac.uk/spm/doc/manual.pdf‎):
# Chap 26
# DARTEL TOOLS

# This toolbox is based around the “A Fast Diffeomorphic Registration Algorithm” paper [3] .
# The idea is to register images by computing a “flow field”, which can then be “exponentiated”
# to generate both forward and backward deformations. Currently, the software only works with
# images that have isotropic voxels, identical dimensions and which are in approximate alignment
# with each other. One of the reasons for this is that the approach assumes circulant boundary
# conditions, which makes modelling global rotations impossible. Another reason why the images
# should be approximately aligned is because there are interactions among the transformations that
# are minimised by beginning with images that are already almost in register. This problem could
# be alleviated by a time varying flow field, but this is currently computationally impractical.
# Because of these limitations, images should first be imported. This involves taking the
# “* seg sn.mat” files produced by the segmentation code of SPM5, and writing out rigidly trans-
# formed versions of the tissue class images, such that they are in as close alignment as possible
# with the tissue probability maps. Rigidly transformed original images can also be generated, with
# the option to have skull-stripped versions.
# The next step is the registration itself. This can involve matching single images together, or it
# can involve the simultaneous registration of e.g. GM with GM, WM with WM and 1-(GM+WM)
# with 1-(GM+WM) (when needed, the 1-(GM+WM) class is generated implicitly, so there is no
# need to include this class yourself). This procedure begins by creating a mean of all the images,
# which is used as an initial template. Deformations from this template to each of the individual
# images are computed, and the template is then re-generated by applying the inverses of the
# deformations to the images and averaging. This procedure is repeated a number of times.
# Finally, warped versions of the images (or other images that are in alignment with them) can
# be generated.
# This toolbox is not yet seamlessly integrated into the SPM package. Eventually, the plan
# is to use many of the ideas here as the default strategy for spatial normalisation. The toolbox
# may change with future updates. There will also be a number of other (as yet unspecified)
# extensions, which may include a variable velocity version (related to LDDMM). Note that the
# Fast Diffeomorphism paper only describes a sum of squares objective function. The multinomial
# objective function is an extension, based on a more appropriate model for aligning binary data
# to a template.

# 26.2
# Run DARTEL (create Templates)
# Run the DARTEL nonlinear image registration procedure. This involves iteratively matching all
# the selected images to a template generated from their own mean. A series of Template*.nii files
# are generated, which become increasingly crisp as the registration proceeds.
#
# When using with many groups of images, check whether subjects are the same on the two lists
#

from __future__ import print_function
from brainvisa.processes import *
import brainvisa.tools.spm_run as spm
from brainvisa.tools.spm_DARTEL import initialize_DARTEL_create_templates_parameters_withSPM8Default, write_DARTEL_create_Templates_batch

#------------------------------------------------------------------------------
configuration = Application().configuration
#------------------------------------------------------------------------------

def validation():
  return spm.validation(configuration)

#------------------------------------------------------------------------------

userLevel = 1
name = 'Run DARTEL (create Templates)'

#------------------------------------------------------------------------------

signature = Signature(
    'Images_1', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
    'Images_2', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
    'Template_basename', String(), 
    'Regularisation_form', Choice(('Linear Elastic Energy', """0"""), ('Membrane Energy', """1"""),('Bending Energy', """2""") ),
    
    # Outer Iteration 1
    'Inner_iteration_1', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_1', String(),
    'Time_step_1', Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_1', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),

    # Outer Iteration 2
    'Inner_iteration_2', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_2', String(),
    'Time_step_2', Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_2', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),

    # Outer Iteration 3
    'Inner_iteration_3', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_3', String(),
    'Time_step_3',  Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_3', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),

    # Outer Iteration 4
    'Inner_iteration_4', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_4', String(),
    'Time_step_4',  Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_4', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),

    # Outer Iteration 5
    'Inner_iteration_5', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_5', String(),
    'Time_step_5',  Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_5', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),

    # Outer Iteration 6
    'Inner_iteration_6', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10') ),
    'Regularisation_parameters_6', String(),
    'Time_step_6',  Choice( ("""'1'""", 0), ("""'2'""", 1), ("""'4'""", 2), ("""'8'""", 3),  ("""'16'""", 4), ("""'32'""", 5), ("""'64'""", 6), ("""'128'""", 7), ("""'256'""", 8), ("""'512'""", 9)),
    'Smoothing_parameter_6', Choice(("""'None'""", '0' ), ('0.5', '0.5'), ('1', '1'), ('2', '2'), ('4', '4'), ('8', '8'),  ('16', '16'), ('32', '32')),
   
    # Optimisation settings
    'LM_Regularisation', Float(),
    'Cycles', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ),
    'Iterations', Choice( ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ),
    
    'batch_location', String(),
 )

#------------------------------------------------------------------------------

def initialization(self):
    self.setOptional( 'Images_2' )
    
    initialize_DARTEL_create_templates_parameters_withSPM8Default(self)
  
    self.addLink( 'batch_location', 'Images_1', self.update_batch_location )

#------------------------------------------------------------------------------
# Function called when Images_1 are selected (or Images_1 selection change)
#
def update_batch_location( self, proc ):
    if len( self.Images_1 ) > 0:
        imgPath = str( self.Images_1[0] )
        imgDir = imgPath[:imgPath.rindex('/') + 1]
        return imgDir + 'batch_SPM_DARTEL_create_templates.m'
    

#------------------------------------------------------------------------------
def execution( self, context ):

    print("\n start ", name, "\n")
        
    spmJobFile = self.batch_location
        
    if ( len( self.Images_2 ) == 0 or len( self.Images_1 ) == len( self.Images_2 ) ):
        
        images_1_path = []
        images_2_path = []
        for img_1, img_2 in zip( self.Images_1, self.Images_2 ):
            images_1_path.append( img_1.fullPath() )
            images_2_path.append( img_2.fullPath() )
        
        
        inner_iteration = []
        reg_params = []
        time_step = []
        smooth_param =  []
        inner_iteration.append( self.Inner_iteration_1 )
        inner_iteration.append( self.Inner_iteration_2 )
        inner_iteration.append( self.Inner_iteration_3 )
        inner_iteration.append( self.Inner_iteration_4 )
        inner_iteration.append( self.Inner_iteration_5 )
        inner_iteration.append( self.Inner_iteration_6 )
        reg_params.append( self.Regularisation_parameters_1 )
        reg_params.append( self.Regularisation_parameters_2 )
        reg_params.append( self.Regularisation_parameters_3 )
        reg_params.append( self.Regularisation_parameters_4 )
        reg_params.append( self.Regularisation_parameters_5 )
        reg_params.append( self.Regularisation_parameters_6 ) 
        time_step.append( self.Time_step_1 )
        time_step.append( self.Time_step_2 )
        time_step.append( self.Time_step_3 )
        time_step.append( self.Time_step_4 )
        time_step.append( self.Time_step_5 )
        time_step.append( self.Time_step_6 )
        smooth_param.append( self.Smoothing_parameter_1 )
        smooth_param.append( self.Smoothing_parameter_2 )
        smooth_param.append( self.Smoothing_parameter_3 )
        smooth_param.append( self.Smoothing_parameter_4 )
        smooth_param.append( self.Smoothing_parameter_5 )
        smooth_param.append( self.Smoothing_parameter_6 )
            
        matfilePath = self.write_DARTEL_create_Templates_batch( spmJobFile, images_1_path, images_2_path, self.Template_basename, self.Regularisation_form, inner_iteration, reg_params, time_step, smooth_param, self.LM_Regularisation, self.Cycles, self.Iterations )
    
        spm.run(context, configuration, matfilePath)#, isMatlabMandatory=True) 
        
    else:
        context.error( "ERROR (number of images in list 1 (Images_1 parameter) is different of number of images in list 2 (Images_2 parameter) " )
      
    
    print("\n stop ", name, "\n")
