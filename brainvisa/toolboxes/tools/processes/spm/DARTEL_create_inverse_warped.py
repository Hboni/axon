# -*- coding: utf-8 -*-
"""
Created on Wed Oct 23 11:22:16 2014

@author: jlebenbe
"""

#------------------------------------------------------------------------------        
# FROM spm documentation (SPM8 manual: www.fil.ion.ucl.ac.uk/spm/doc/manual.pdf‎):
# Chap 26
# DARTEL TOOLS

# This toolbox is based around the “A Fast Diffeomorphic Registration Algorithm” paper [3] .
# The idea is to register images by computing a “flow field”, which can then be “exponentiated”
# to generate both forward and backward deformations. Currently, the software only works with
# images that have isotropic voxels, identical dimensions and which are in approximate alignment
# with each other. One of the reasons for this is that the approach assumes circulant boundary
# conditions, which makes modelling global rotations impossible. Another reason why the images
# should be approximately aligned is because there are interactions among the transformations that
# are minimised by beginning with images that are already almost in register. This problem could
# be alleviated by a time varying flow field, but this is currently computationally impractical.
# Because of these limitations, images should first be imported. This involves taking the
# “* seg sn.mat” files produced by the segmentation code of SPM5, and writing out rigidly trans-
# formed versions of the tissue class images, such that they are in as close alignment as possible
# with the tissue probability maps. Rigidly transformed original images can also be generated, with
# the option to have skull-stripped versions.
# The next step is the registration itself. This can involve matching single images together, or it
# can involve the simultaneous registration of e.g. GM with GM, WM with WM and 1-(GM+WM)
# with 1-(GM+WM) (when needed, the 1-(GM+WM) class is generated implicitly, so there is no
# need to include this class yourself). This procedure begins by creating a mean of all the images,
# which is used as an initial template. Deformations from this template to each of the individual
# images are computed, and the template is then re-generated by applying the inverses of the
# deformations to the images and averaging. This procedure is repeated a number of times.
# Finally, warped versions of the images (or other images that are in alignment with them) can
# be generated.
# This toolbox is not yet seamlessly integrated into the SPM package. Eventually, the plan
# is to use many of the ideas here as the default strategy for spatial normalisation. The toolbox
# may change with future updates. There will also be a number of other (as yet unspecified)
# extensions, which may include a variable velocity version (related to LDDMM). Note that the
# Fast Diffeomorphism paper only describes a sum of squares objective function. The multinomial
# objective function is an extension, based on a more appropriate model for aligning binary data
# to a template.

from __future__ import print_function
from brainvisa.processes import *
import brainvisa.tools.spm_run as spm
from brainvisa.tools.spm_DARTEL import initialize_DARTEL_create_inverse_warped_parameters_withSPM8Default, write_DARTEL_create_inverse_warped_batch
#------------------------------------------------------------------------------
configuration = Application().configuration
#------------------------------------------------------------------------------

def validation():
  return spm.validation(configuration)

#------------------------------------------------------------------------------

userLevel = 1
name = 'DARTEL: create inverse warped'

signature = Signature(
                      'Flow_fields', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
                      'Images', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
                      'Time_steps', Choice (( '1', '0' ), ( '2', '1' ), ( '4', '2' ), ( '8', '3' ), ( '16', '4' ), ( '32', '5' ), ( '64', '6' ), ( '128', '7' ), ( '256', '8' ), ( '512', '9' ) ),
                      'Interpolation', Choice(('Nearest neighbour', """0"""), ('Trilinear', """1"""), ('2nd Degree sync', """2"""), ('3rd Degree sync', """3"""), ('4th Degree sync', """4"""), ('5th Degree sync', """5"""), ('6thd Degree sync', """6"""), ('7th Degree sync', """7""")),
                      'batch_location', String(),
                      )

#------------------------------------------------------------------------------

def initialization(self):
    initialize_DARTEL_create_inverse_warped_parameters_withSPM8Default( self )

    self.addLink( 'batch_location', 'Images', self.update_batch_location )
    
    
#------------------------------------------------------------------------------
# Function called when Images are selected (or Images selection change)
#
def update_batch_location( self, proc ):
    if len( self.Images ) > 0:
        imgPath = str( self.Images[0] )
        imgDir = imgPath[:imgPath.rindex('/') + 1]
        return imgDir + 'batch_SPM_DARTEL_create_inverse_warped.m'
    return
    

#------------------------------------------------------------------------------
def execution( self, context ):

    print("\n start ", name, "\n")
        
    spmJobFile = self.batch_location

    # test whether we have same number of flow fields and images to inversely warp
    if ( len( self.Images ) == len( self.Flow_fields ) ):
        flow_fields_path = []
        for img in self.Flow_fields:
            flow_fields_path.append( img.fullPath() )
        
        images_path = []
        if len( self.Images )>0:
            for img in self.Images:
                images_path.append( img.fullPath() )
                
        matfilePath = self.write_DARTEL_create_inverse_warped_batch( spmJobFile, flow_fields_path, images_path,  self.Time_steps, self.Interpolation)

        spm.run(context, configuration, matfilePath)#, isMatlabMandatory=True)

    else:
         context.error( "ERROR (the number of images to inversely warp is different of the number of flow fields) " )

    print("\n stop ", name, "\n")
