# -*- coding: utf-8 -*-
#  This software and supporting documentation are distributed by
#      Institut Federatif de Recherche 49
#      CEA/NeuroSpin, Batiment 145,
#      91191 Gif-sur-Yvette cedex
#      France
#
# This software is governed by the CeCILL license version 2 under
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the
# terms of the CeCILL license version 2 as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL license version 2 and that you accept its terms.

#------------------------------------------------------------------------------        
# FROM spm documentation (SPM8 manual: www.fil.ion.ucl.ac.uk/spm/doc/manual.pdf‎):
# Chap 26
# DARTEL TOOLS

# This toolbox is based around the “A Fast Diffeomorphic Registration Algorithm” paper [3] .
# The idea is to register images by computing a “flow field”, which can then be “exponentiated”
# to generate both forward and backward deformations. Currently, the software only works with
# images that have isotropic voxels, identical dimensions and which are in approximate alignment
# with each other. One of the reasons for this is that the approach assumes circulant boundary
# conditions, which makes modelling global rotations impossible. Another reason why the images
# should be approximately aligned is because there are interactions among the transformations that
# are minimised by beginning with images that are already almost in register. This problem could
# be alleviated by a time varying flow field, but this is currently computationally impractical.
# Because of these limitations, images should first be imported. This involves taking the
# “* seg sn.mat” files produced by the segmentation code of SPM5, and writing out rigidly trans-
# formed versions of the tissue class images, such that they are in as close alignment as possible
# with the tissue probability maps. Rigidly transformed original images can also be generated, with
# the option to have skull-stripped versions.
# The next step is the registration itself. This can involve matching single images together, or it
# can involve the simultaneous registration of e.g. GM with GM, WM with WM and 1-(GM+WM)
# with 1-(GM+WM) (when needed, the 1-(GM+WM) class is generated implicitly, so there is no
# need to include this class yourself). This procedure begins by creating a mean of all the images,
# which is used as an initial template. Deformations from this template to each of the individual
# images are computed, and the template is then re-generated by applying the inverses of the
# deformations to the images and averaging. This procedure is repeated a number of times.
# Finally, warped versions of the images (or other images that are in alignment with them) can
# be generated.
# This toolbox is not yet seamlessly integrated into the SPM package. Eventually, the plan
# is to use many of the ideas here as the default strategy for spatial normalisation. The toolbox
# may change with future updates. There will also be a number of other (as yet unspecified)
# extensions, which may include a variable velocity version (related to LDDMM). Note that the
# Fast Diffeomorphism paper only describes a sum of squares objective function. The multinomial
# objective function is an extension, based on a more appropriate model for aligning binary data
# to a template.

# CHAPTER 26. DARTEL TOOLS
# Create Warped
# This allows spatially normalised images to be generated. Note that voxel sizes and bounding
# boxes can not be adjusted, and that there may be strange effects due to the boundary conditions
# used by the warping. Also note that the warped images are not in Talairach or MNI space. The
# coordinate system is that of the average shape and size of the subjects to which DARTEL was
# applied. In order to have MNI-space normalised images, then the Deformations Utility can be
# used to compose the individual DARTEL warps, with a deformation field that matches (e.g.) the
# Template grey matter generated by DARTEL, with one of the grey matter volumes released with
# SPM.


from __future__ import print_function
from brainvisa.processes import *
import brainvisa.tools.spm_run as spm
from brainvisa.tools.spm_DARTEL import initialize_DARTEL_create_warped_parameters_withSPM8Default, write_DARTEL_create_warped_batch
#------------------------------------------------------------------------------
configuration = Application().configuration
#------------------------------------------------------------------------------

def validation():
  return spm.validation(configuration)

#------------------------------------------------------------------------------

userLevel = 1
name = 'DARTEL: create warped'

signature = Signature(
                      'Flow_fields', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
                      'Images', ListOf( ReadDiskItem( '4D Volume', 'Aims readable volume formats' ) ),
                      'Modulation', Choice( ('Preserve concentration ("no modulation")', '0'), ('Preserve amount ("modulation")', '1') ),
                      'Time_steps', Choice (( '1', '0' ), ( '2', '1' ), ( '4', '2' ), ( '8', '3' ), ( '16', '4' ), ( '32', '5' ), ( '64', '6' ), ( '128', '7' ), ( '256', '8' ), ( '512', '9' ) ),
                      'Interpolation', Choice(('Nearest neighbour', """0"""), ('Trilinear', """1"""), ('2nd Degree sync', """2"""), ('3rd Degree sync', """3"""), ('4th Degree sync', """4"""), ('5th Degree sync', """5"""), ('6thd Degree sync', """6"""), ('7th Degree sync', """7""")),
                      'batch_location', String(),
                      )

#------------------------------------------------------------------------------

def initialization(self):
    initialize_DARTEL_create_warped_parameters_withSPM8Default( self )

    self.addLink( 'batch_location', 'Images', self.update_batch_location )
    
    
#------------------------------------------------------------------------------
# Function called when Images are selected (or Images selection change)
#
def update_batch_location( self, proc ):
    if len( self.Images ) > 0:
        imgPath = str( self.Images[0] )
        imgDir = imgPath[:imgPath.rindex('/') + 1]
        return imgDir + 'batch_SPM_DARTEL_create_warped.m'
    return
    

#------------------------------------------------------------------------------
def execution( self, context ):

    print("\n start ", name, "\n")
        
    spmJobFile = self.batch_location

    # test whether we have same number of flow fields and images to warp
    if ( len( self.Images ) == len( self.Flow_fields ) ):
        flow_fields_path = []
        for img in self.Flow_fields:
            flow_fields_path.append( img.fullPath() )
        
        images_path = []
        if len( self.Images )>0:
            for img in self.Images:
                images_path.append( img.fullPath() )
                
        matfilePath = self.write_DARTEL_create_warped_batch( spmJobFile, flow_fields_path, images_path,  self.Modulation, self.Time_steps, self.Interpolation)

        spm.run(context, configuration, matfilePath)#, isMatlabMandatory=True)

    else:
         context.error( "ERROR (the number of images to warp is different of the number of flow fields) " )

    print("\n stop ", name, "\n")
    
